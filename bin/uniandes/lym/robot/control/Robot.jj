/*
Gramatica para el Robot:
Autor: Alejandro Arango
Modificado por: Silvia Takahashi
Modificado por: Juan Pablo Morales.
Agregadas producciones para manejar globos
Modificado por Silvia Takahashi


 **/


options 
{
  
	LOOKAHEAD=1; 
	IGNORE_CASE=true;
	STATIC = false;
	
}
   

PARSER_BEGIN(Robot)

package uniandes.lym.robot.control;

import uniandes.lym.robot.kernel.*;
import uniandes.lym.robot.view.Console;
 
import java.awt.Point;
import java.io.*;
import java.util.Vector;
import java.util.LinkedList;

@SuppressWarnings("serial")
public class Robot 
{


	private RobotWorldDec world;
	
	
	void setWorld(RobotWorld w) {
		world = (RobotWorldDec) w;	
	}

	String salida=new String();
}
PARSER_END(Robot)

SKIP:
{
		" "
	|	"\r"
	|	"\t"
	| 	"\n"
}

TOKEN:
{
  // COMMANDS

		< MOVE:			"move" >
	| 	< RIGHT: 		"right" >
	| 	< PUT: 			"put" >
	| 	< PICK: 		"pick" >
	| 	< POP: 			"pop" >
	|  	< GO: 			"go" >
    |  	< HOP:  		"hop" >
    |   < TURN_TO_MY:	"turntomy" >
    |   < TURN_TO_THE:	"turntothe" >
    |   < WALK:			"walk" >
    |   < JUMP:			"jump" >
    |   < DROP:			"drop" >
    |   < GRAB:			"grab" >
    |   < LET_GO:		"letgo" >
    |   < MOVES:		"moves" >
    |	< NOP: 			"nop"  >
    |	< SAFE_EXE: 	"safeexe"  >
    | 	< EXEC:			"exec" >
}

TOKEN:
{
  // DIRECTIONS

		< LEFT:			"left" >
	| 	< BACK: 		"back" >
	| 	< FRONT: 		"front" >
	| 	< NORTH:		"north" >
	| 	< SOUTH: 		"south" >
	| 	< EAST: 		"east" >
	|  	< WEST: 		"west" >
	|   < FORWARD:		"forward" >
	|   < BACKWARDS:	"backwards" >
}

TOKEN:
{
  // CONSTANTS

		< SIZE:				"size" >
	| 	< MY_X: 			"myx" >
	| 	< MY_Y:				"myy" >
	| 	< MY_CHIPS: 		"mychips" >
	| 	< MY_BALLOONS: 		"myballoons" >
	|  	< BALLOONS_HERE:	"balloonshere" >
	|   < CHIPS_HERE:		"chipshere" >
	|   < ROOM_FOR_CHIPS:	"roomforchips" >
}

TOKEN:
{
  // DEFINITIONS
  
		< NEW: 		"new"  >
	|	< VAR: 		"var"  >
	|	< MACRO:	"macro"  >

}

TOKEN:
{
  // CONTROL STRUCTURES
  
		< IF:		"if" >
	|	< THEN: 	"then"  >
	|	< ELSE: 	"else"  >
	|	< FI:		"fi"  >
	|	< DO:		"do"  >
	|	< OD:		"od"  >
	|	< REP:		"rep"  >
	|	< TIMES:	"times"  >
	|	< PER:		"per"  >

}

TOKEN:
{
  // CONDITIONS
  
		< IS_BLOCKED:	"isblocked?" >
	|	< IS_FACING: 	"isfacing?"  >
	|	< ZERO: 		"zero?"  >
	|	< NOT:			"not"  >

}

TOKEN:
{
  // OBJECTS
		< BALLOONS:  "balloons" >
	|	< CHIPS:     "chips"  >	

}

TOKEN:
{
  // SYMBOLS

		< LEFT_PARENTEHSIS:  	"(" >
	| 	< RIGHT_PARENTEHSIS:	")" >
	| 	< UNDERSCORE:  			"_" >
	|	< COMMA:				","  >
	|	< LEFT_BRACE: 			"{"  >
	|	< RIGHT_BRACE: 			"}"  >
	|	< EQUAL: 				"="  >
	|	< SEMICOLON: 			";"  >  
	| 	< NUMBER: 				(< DIGIT >)+ >
	|  	< #DIGIT: 				["0"-"9"] >
	| 	< NAME: 				< CHARACTER >(< CHARACTER > | < UNDERSCORE > | < DIGIT >)*>
	| 	< #CHARACTER: 			["a"-"z"] >

}

//boolean command(uniandes.lym.robot.view.Console sistema) :
boolean command(Console sistema):
{	
	
	int x,y;
	salida=new String();	
}


{
	(
		input()

	{
		try {
					Thread.sleep(900);
			} catch (InterruptedException e) {
						System.err.format("IOException: %s%n", e);
				}
					
		sistema.printOutput(salida);
		return true;
	})+

	| <EOF> {return false;} 
}

void input(): {
} {
  executionCommand() | definition()
}

void executionCommand(): {
} {
	< EXEC > B() 
}

void definition(): {
} {
	< NEW > (varDefinition() | macroDefinition())
}

void varDefinition(): {
} {
	< VAR > < NAME > < EQUAL > n()
}

void macroDefinition(): {
} {
	< MACRO > < NAME > < LEFT_PARENTEHSIS > params() < RIGHT_PARENTEHSIS > B()
}

void n(): {
} {
	< NUMBER > | < NAME > | constant()
}

void constant(): {
} {
		< SIZE>
	| 	< MY_X >
	| 	< MY_Y >
	| 	< MY_CHIPS >
	| 	< MY_BALLOONS >
	|  	< BALLOONS_HERE >
	|   < CHIPS_HERE >
	|   < ROOM_FOR_CHIPS >
}

void params(): {
} {
	(< NAME > (< COMMA > < NAME >)*)?
}

void B(): {
} {
	<LEFT_BRACE > (instruction() < SEMICOLON >)+ <RIGHT_BRACE >
}

void instruction(): {
} {
	commandGroup() | controlStructure()
}

void commandGroup(): {
} {
		move()
	|	right()
	| 	put()
	| 	pick()
	| 	pop()
	| 	hop()
	| 	go()
	| 	assignmentOrMacroInvocation()
	| 	turnToMy()
	| 	turnToThe()
	| 	walk()
	| 	jump()
	| 	drop()
	| 	grab()
	| 	letGo()
	| 	moves()
	|  < NOP >
	| 	safeExe()
	 
}

void move(): {
} {
	< MOVE > < LEFT_PARENTEHSIS > n() < RIGHT_PARENTEHSIS > 
}

void right(): {
} {
	< RIGHT > < LEFT_PARENTEHSIS > < RIGHT_PARENTEHSIS > 
}

void put(): {
} {
	< PUT > < LEFT_PARENTEHSIS > object() < COMMA > n() < RIGHT_PARENTEHSIS > 
}

void pick(): {
} {
	< PICK > < LEFT_PARENTEHSIS > ((object() < COMMA > n()) | n()) < RIGHT_PARENTEHSIS > 
}

void pop(): {
} {
	< POP > < LEFT_PARENTEHSIS > n() < RIGHT_PARENTEHSIS > 
}

void hop(): {
} {
	< HOP > < LEFT_PARENTEHSIS > n() < RIGHT_PARENTEHSIS > 
}

void go(): {
} {
	< GO > < LEFT_PARENTEHSIS > n() < COMMA > n() < RIGHT_PARENTEHSIS > 
}

void object(): {
} {
	< CHIPS > | < BALLOONS >
}

void assignmentOrMacroInvocation(): {
} {
	< NAME > (assignment() | macroInvocation())
}

void assignment(): {
} {
	< EQUAL > n()
}

void macroInvocation(): {
} {
	< LEFT_PARENTEHSIS > params() < RIGHT_PARENTEHSIS > 
}

void turnToMy(): {
} {
	< TURN_TO_MY > < LEFT_PARENTEHSIS > (< LEFT > | < RIGHT > | < BACK >) < RIGHT_PARENTEHSIS > 
}

void turnToThe(): {
} {
	< TURN_TO_THE > < LEFT_PARENTEHSIS > (< NORTH > | < SOUTH > | < EAST > | < WEST >) < RIGHT_PARENTEHSIS > 
}

void walk(): {
} {
	< WALK > < LEFT_PARENTEHSIS > n() < RIGHT_PARENTEHSIS > 
}

void jump(): {
} {
	< JUMP > < LEFT_PARENTEHSIS > n() < RIGHT_PARENTEHSIS > 
}

void drop(): {
} {
	< DROP > < LEFT_PARENTEHSIS > n() < RIGHT_PARENTEHSIS > 
}

void grab(): {
} {
	< GRAB > < LEFT_PARENTEHSIS > n() < RIGHT_PARENTEHSIS > 
}

void letGo(): {
} {
	< LET_GO > < LEFT_PARENTEHSIS > n() < RIGHT_PARENTEHSIS > 
}

void moves(): {
} {
	< MOVES > < LEFT_PARENTEHSIS > (< FORWARD > | < RIGHT > | < LEFT > | < BACKWARDS >) (< COMMA > (< FORWARD > | < RIGHT > | < LEFT > | < BACKWARDS >))* < RIGHT_PARENTEHSIS > 
}

void safeExe(): {
} {
	< SAFE_EXE > < LEFT_PARENTEHSIS > (walk() | jump() | drop() | pick() | grab() | letGo() | pop()) < RIGHT_PARENTEHSIS > 
}

void controlStructure(): {
} {
		iff() | doo() | rep()
}

void iff(): {
} {
		< IF > < LEFT_PARENTEHSIS > condition() < RIGHT_PARENTEHSIS > < THEN > B() < ELSE > B() < FI >
}

void doo(): {
} {
		< DO > < LEFT_PARENTEHSIS > condition() < RIGHT_PARENTEHSIS > B() < OD >
}

void rep(): {
} {
		< REP > n() < TIMES >  B() < PER >
}

void condition(): {
} {
	isBlocked() | isFacing() | zero() | not()		
}


void isBlocked(): {
} {
	< IS_BLOCKED > < LEFT_PARENTEHSIS > (< LEFT > | < RIGHT > | < FRONT > | < BACK >) < RIGHT_PARENTEHSIS >
}

void isFacing(): {
} {
	< IS_FACING > < LEFT_PARENTEHSIS > (< NORTH > | < SOUTH > | < EAST > | < WEST >) < RIGHT_PARENTEHSIS >
}

void zero(): {
} {
	< ZERO > < LEFT_PARENTEHSIS > n() < RIGHT_PARENTEHSIS >
}

void not(): {
} {
	< NOT > < LEFT_PARENTEHSIS > condition() < RIGHT_PARENTEHSIS >
}





// ------------------------------------------

/*
void put() :
{
	int f=1;	
}
{
	( <CHIPS>    "," f=num() {world.putChips(f); salida = "Command:  Put Chips"; })
	|  	  ( <BALLOONS>   "," f=num() {world.putBalloons(f); salida = "Command:  Put Balloons";})	 

}
*/

void get() :
{
	int f=1;	
}
{
	( <CHIPS>   "," f=num() {world.pickChips(f);salida = "Command:  Pick chips";})
	|  	  ( <BALLOONS>   "," f=num() {world.grabBalloons(f);salida="Command:  Pick balloons";})	 

}




/**
	* Unsigned decimal number
	* @return the corresponding value of the string
	* @error  corresponding value is too large
	*/

int num() throws Error:
{	
	int total=1;
}
{
	<NUMBER>
	{
		try 
		{
			total = Integer.parseInt(token.image);
		} 
		catch (NumberFormatException ee) 
		{
			throw new Error("Number out of bounds: "+token.image+" !!");
		}
		return total;
	}
}

