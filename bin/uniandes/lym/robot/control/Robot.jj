/*
Gramatica para el Robot:
Autor: Alejandro Arango
Modificado por: Silvia Takahashi
Modificado por: Juan Pablo Morales.
Agregadas producciones para manejar globos
Modificado por Silvia Takahashi


 **/


options 
{
  
	LOOKAHEAD=1; 
	IGNORE_CASE=true;
	STATIC = false;
	
}
   

PARSER_BEGIN(Robot)

package uniandes.lym.robot.control;

import uniandes.lym.robot.kernel.*;
import uniandes.lym.robot.view.Console;
 
import java.awt.Point;
import java.io.*;
import java.util.Vector;
import java.util.LinkedList;

import java.util.HashMap;
import java.util.Map;
import java.lang.String;
import java.lang.Integer;
import java.util.ArrayList;

@SuppressWarnings("serial")
public class Robot 
{

	public static Map<Integer, Map<String, Integer>> variablesForLevel = new HashMap<>();
	public static int currentLevel = 0;
	public static ArrayList<String> currentMacroParameters = new ArrayList<String>();
	public static boolean inMacroDefinition = false;
	public static Map<String, Integer> macroParametersQuantity = new HashMap<>();
	public static String currentMacroNameInMacroDefinition;
	public static boolean receivingMacroParameters = false;
	public static boolean inVariableAssignment = false;
	public static String currentMacroNameRecievingParameters;

	private RobotWorldDec robotWorld;
	
	
	
	void setWorld(RobotWorld w) {
		robotWorld = (RobotWorldDec) w;	
	}

	String salida=new String();
}
PARSER_END(Robot)

SKIP:
{
		" "
	|	"\r"
	|	"\t"
	| 	"\n"
}

TOKEN:
{
  // COMMANDS

		< MOVE:			"move" >
	| 	< RIGHT: 		"right" >
	| 	< PUT: 			"put" >
	| 	< PICK: 		"pick" >
	| 	< POP: 			"pop" >
	|  	< GO: 			"go" >
    |  	< HOP:  		"hop" >
    |   < TURN_TO_MY:	"turntomy" >
    |   < TURN_TO_THE:	"turntothe" >
    |   < WALK:			"walk" >
    |   < JUMP:			"jump" >
    |   < DROP:			"drop" >
    |   < GRAB:			"grab" >
    |   < LET_GO:		"letgo" >
    |   < MOVES:		"moves" >
    |	< NOP: 			"nop"  >
    |	< SAFE_EXE: 	"safeexe"  >
    | 	< EXEC:			"exec" >
}

TOKEN:
{
  // DIRECTIONS

		< LEFT:			"left" >
	| 	< BACK: 		"back" >
	| 	< FRONT: 		"front" >
	| 	< NORTH:		"north" >
	| 	< SOUTH: 		"south" >
	| 	< EAST: 		"east" >
	|  	< WEST: 		"west" >
	|   < FORWARD:		"forward" >
	|   < BACKWARDS:	"backwards" >
}

TOKEN:
{
  // CONSTANTS

		< SIZE:				"size" >
	| 	< MY_X: 			"myx" >
	| 	< MY_Y:				"myy" >
	| 	< MY_CHIPS: 		"mychips" >
	| 	< MY_BALLOONS: 		"myballoons" >
	|  	< BALLOONS_HERE:	"balloonshere" >
	|   < CHIPS_HERE:		"chipshere" >
	|   < ROOM_FOR_CHIPS:	"roomforchips" >
}

TOKEN:
{
  // DEFINITIONS
  
		< NEW: 		"new"  >
	|	< VAR: 		"var"  >
	|	< MACRO:	"macro"  >

}

TOKEN:
{
  // CONTROL STRUCTURES
  
		< IF:		"if" >
	|	< THEN: 	"then"  >
	|	< ELSE: 	"else"  >
	|	< FI:		"fi"  >
	|	< DO:		"do"  >
	|	< OD:		"od"  >
	|	< REP:		"rep"  >
	|	< TIMES:	"times"  >
	|	< PER:		"per"  >

}

TOKEN:
{
  // CONDITIONS
  
		< IS_BLOCKED:	"isblocked?" >
	|	< IS_FACING: 	"isfacing?"  >
	|	< ZERO: 		"zero?"  >
	|	< NOT:			"not"  >

}

TOKEN:
{
  // OBJECTS
		< BALLOONS:  "balloons" >
	|	< CHIPS:     "chips"  >	

}

TOKEN:
{
  // SYMBOLS

		< LEFT_PARENTEHSIS:  	"(" >
	| 	< RIGHT_PARENTEHSIS:	")" >
	| 	< UNDERSCORE:  			"_" >
	|	< COMMA:				","  >
	|	< LEFT_BRACE: 			"{"  >
	|	< RIGHT_BRACE: 			"}"  >
	|	< EQUAL: 				"="  >
	|	< SEMICOLON: 			";"  >  
	| 	< NUMBER: 				(< DIGIT >)+ >
	|  	< #DIGIT: 				["0"-"9"] >
	| 	< NAME: 				< CHARACTER >(< CHARACTER > | < UNDERSCORE > | < DIGIT >)*>
	| 	< #CHARACTER: 			["a"-"z"] >

}

//boolean command(uniandes.lym.robot.view.Console sistema) :
boolean command(Console sistema):
{	
	
	int x,y;
	salida=new String();	
}


{
	(
		input()

	{
		try {
					Thread.sleep(900);
			} catch (InterruptedException e) {
						System.err.format("IOException: %s%n", e);
				}
					
		sistema.printOutput(salida);
		return true;
	})+

	| <EOF> {return false;} 
}

void input(): {
} {
  executionCommand() | definition()
}

void executionCommand(): {
} {
	< EXEC > B() 
}

void definition(): {
} {
	< NEW > (varDefinition() | macroDefinition())
}

void varDefinition(): {
  String variableName;
  int variableValue;
} {
	< VAR > < NAME > { variableName = token.image.toLowerCase();} < EQUAL > variableValue=n(true) {
	  	
		if(!Robot.variablesForLevel.containsKey(Robot.currentLevel)) {
		  Map<String, Integer> internalMap = new HashMap<>();
		  Robot.variablesForLevel.put(Robot.currentLevel, internalMap);
		}
		Map<String, Integer> internalMap = Robot.variablesForLevel.get(Robot.currentLevel);
		if(internalMap.containsKey(variableName)) {
		  throw new Error("Variable " + variableName + " has been already declared.");
		}else {
		  internalMap.put(variableName, variableValue);
		  Robot.variablesForLevel.put(Robot.currentLevel, internalMap);
		  System.out.println(variablesForLevel);
		}
		
		
	}
}

void macroDefinition(): {
} {
	< MACRO > { Robot.inMacroDefinition = true; } < NAME > {
	  	if(Robot.macroParametersQuantity.containsKey(token.image)) throw new Error("There is a macro already declared with the name '" + token.image + "'.");
		Robot.currentMacroNameInMacroDefinition = token.image;
	} < LEFT_PARENTEHSIS > params() < RIGHT_PARENTEHSIS > { Robot.inMacroDefinition = false; Robot.currentMacroNameInMacroDefinition = null; }  B() { Robot.currentMacroParameters = new ArrayList<String>(); System.out.println(Robot.currentMacroParameters);}
}

Integer n(boolean inVariableDefinition): {
  int constantValue;
  int valueInVariable = 0;
} { 
		< NUMBER > {
		  	if(inVariableDefinition) return Integer.parseInt(token.image);
		  	else if(Robot.inVariableAssignment) return Integer.parseInt(token.image);
		  	else if(Robot.inMacroDefinition) throw new Error("Numbers can not be parameters.");
			else if(Robot.receivingMacroParameters) {
	 		  	Robot.macroParametersQuantity.put(Robot.currentMacroNameRecievingParameters, Robot.macroParametersQuantity.get(Robot.currentMacroNameRecievingParameters)-1);
				return Integer.parseInt(token.image);
	 		}
		  	return null;
		}
	| 	< NAME > {
	  		String variableName = token.image.toLowerCase();
	  		boolean found = false;

	  		// Para la definicion de una variable: devuelve el valor de la variable si esta en una definicion de variable, solo lo busca en las variables globales porque dentro de un exec o funcion no se pueden definir variables
	  		if(inVariableDefinition) {
		  		for(int i = Robot.currentLevel; i>=0; i--) {
					Map<String, Integer> variablesInCurrentLevel = Robot.variablesForLevel.get(i);
					if(variablesInCurrentLevel != null && variablesInCurrentLevel.containsKey(variableName)) {
					  found = true;
					  valueInVariable = variablesInCurrentLevel.get(variableName);
					}
		  		}
	  		  	if(found) return valueInVariable;
	  		  	else throw new Error("The variable '" + variableName + "' used in the assignment was not declared before. ");
	  		}

			// Si esta en la asignacion de una variable la busca en las variables globales, locales y parametros
	  		else if(Robot.inVariableAssignment) {
		  		for(int i = Robot.currentLevel; i>=0; i--) {
					Map<String, Integer> variablesInCurrentLevel = Robot.variablesForLevel.get(i);
					if(variablesInCurrentLevel != null && variablesInCurrentLevel.containsKey(variableName)) {
					  found = true;
					  valueInVariable = variablesInCurrentLevel.get(variableName);
					}
		  		}
		  		boolean foundInMacroParameters = false;
		  		for(String element: Robot.currentMacroParameters) {
					if (element.equals(variableName)) {
						foundInMacroParameters = true;
					}
		  		}
	  		  	if(found || foundInMacroParameters) return valueInVariable;
	  		  	else throw new Error("The variable '" + variableName + "' used in the assignment was not declared before. ");
	  		}

			// Si se estan definiendo los parametros de una macro: se aÃ±ade a la lista de variables actuales de la macro
			else if(Robot.inMacroDefinition) {
		  		if(!Robot.currentMacroParameters.contains(token.image)) {
		  		  
		  	  	  if(macroParametersQuantity.containsKey(Robot.currentMacroNameInMacroDefinition))	Robot.macroParametersQuantity.put(Robot.currentMacroNameInMacroDefinition, Robot.macroParametersQuantity.get(Robot.currentMacroNameInMacroDefinition)+1);
		  	  	  else Robot.macroParametersQuantity.put(Robot.currentMacroNameInMacroDefinition, 1);
	
		  		  Robot.currentMacroParameters.add(token.image);
		  		}
		  		else throw new Error("The parameter with the name " + token.image + " is already declared for this macro.");
	 		}

			// Si se esta invocando una macro: para detectar que se pase la cantidad correcta de argumentos y ademas verificar que se encuentre la variable definida sea como variable global o local
	 		else if(Robot.receivingMacroParameters) {
		  		for(int i = Robot.currentLevel; i>=0; i--) {
					Map<String, Integer> variablesInCurrentLevel = Robot.variablesForLevel.get(i);
					if(variablesInCurrentLevel != null && variablesInCurrentLevel.containsKey(variableName)) {
					  found = true;
					  valueInVariable = variablesInCurrentLevel.get(variableName);
					}
		  		}
		  		boolean foundInMacroParameters = false;
		  		for(String element: Robot.currentMacroParameters) {
					if (element.equals(variableName)) {
						foundInMacroParameters = true;
					}
		  		}
	  		  	if(found || foundInMacroParameters) {
	  		  	  
	 		  	Robot.macroParametersQuantity.put(Robot.currentMacroNameRecievingParameters, Robot.macroParametersQuantity.get(Robot.currentMacroNameRecievingParameters)-1);
	  		  	  return valueInVariable;
	  		  	}
	  		  	else throw new Error("The argument '" + variableName + "' was not declared before. ");
	 		}
		

			return null;
	  	}
	| 	constantValue=constant() {
		  	if(inVariableDefinition) return constantValue;
		  	else if(Robot.inVariableAssignment) return constantValue;
		  	else if(Robot.inMacroDefinition) throw new Error("Constants can not be parameters.");
			else if(Robot.receivingMacroParameters) {
	 		  	Robot.macroParametersQuantity.put(Robot.currentMacroNameRecievingParameters, Robot.macroParametersQuantity.get(Robot.currentMacroNameRecievingParameters)-1);
				return constantValue;
	 		}
		  	return null;
		}
}

int constant(): {
} {
		< SIZE> { return robotWorld.getN();}
	| 	< MY_X > { return (int) robotWorld.getPosition().getX(); }
	| 	< MY_Y > { return (int) robotWorld.getPosition().getY(); }
	| 	< MY_CHIPS > { return robotWorld.getMyChips();}
	| 	< MY_BALLOONS > { return robotWorld.getMyBalloons();}
	|  	< BALLOONS_HERE > { return robotWorld.countBalloons();}
	|   < CHIPS_HERE > { return 0; /*TODO*/}
	|   < ROOM_FOR_CHIPS > { return robotWorld.getMyChips();}
}

void params(): {
} {
	(n(false) (< COMMA > n(false))*)?
}

void B(): {
} {
	<LEFT_BRACE > { Robot.currentLevel++;} (instruction() < SEMICOLON >)+ <RIGHT_BRACE > { Robot.currentLevel--; }
}

void instruction(): {
} {
	commandGroup() | controlStructure()
}

void commandGroup(): {
} {
		move()
	|	right()
	| 	put()
	| 	pick()
	| 	pop()
	| 	hop()
	| 	go()
	| 	assignmentOrMacroInvocation()
	| 	turnToMy()
	| 	turnToThe()
	| 	walk()
	| 	jump()
	| 	drop()
	| 	grab()
	| 	letGo()
	| 	moves()
	|  < NOP >
	| 	safeExe()
	 
}

void move(): {
} {
	< MOVE > < LEFT_PARENTEHSIS > n(false) < RIGHT_PARENTEHSIS > 
}

void right(): {
} {
	< RIGHT > < LEFT_PARENTEHSIS > < RIGHT_PARENTEHSIS > 
}

void put(): {
} {
	< PUT > < LEFT_PARENTEHSIS > object() < COMMA > n(false) < RIGHT_PARENTEHSIS > 
}

void pick(): {
} {
	< PICK > < LEFT_PARENTEHSIS > ((object() < COMMA > n(false)) | n(false)) < RIGHT_PARENTEHSIS > 
}

void pop(): {
} {
	< POP > < LEFT_PARENTEHSIS > n(false) < RIGHT_PARENTEHSIS > 
}

void hop(): {
} {
	< HOP > < LEFT_PARENTEHSIS > n(false) < RIGHT_PARENTEHSIS > 
}

void go(): {
} {
	< GO > < LEFT_PARENTEHSIS > n(false) < COMMA > n(false) < RIGHT_PARENTEHSIS > 
}

void object(): {
} {
	< CHIPS > | < BALLOONS >
}

void assignmentOrMacroInvocation(): {
  String macroName;
} {
	< NAME > { macroName = token.image; } (assignment() | macroInvocation(macroName))
}

void assignment(): {
} {
	< EQUAL > { Robot.inVariableAssignment = true; } n(false) { Robot.inVariableAssignment = false; }
}

void macroInvocation(String macroName): {
  int initialParameters = 0;
} {
	< LEFT_PARENTEHSIS > {
	  	Robot.receivingMacroParameters=true;
	  	Robot.currentMacroNameRecievingParameters = macroName;
	  	System.out.println(macroParametersQuantity);
	  	if(Robot.macroParametersQuantity.containsKey(Robot.currentMacroNameRecievingParameters)) initialParameters = Robot.macroParametersQuantity.get(Robot.currentMacroNameRecievingParameters);
	  	else throw new Error("There is not a macro defined with the name '" + Robot.currentMacroNameRecievingParameters + "'.");
	  } params() < RIGHT_PARENTEHSIS > {
		System.out.println(macroParametersQuantity);
		if(Robot.macroParametersQuantity.containsKey(Robot.currentMacroNameRecievingParameters) && Robot.macroParametersQuantity.get(Robot.currentMacroNameRecievingParameters) != 0) throw new Error("The macro invocation for "+ Robot.currentMacroNameRecievingParameters + " did not recieve the correct amount of arguments.");
		if(Robot.macroParametersQuantity.containsKey(Robot.currentMacroNameRecievingParameters)) Robot.macroParametersQuantity.put(Robot.currentMacroNameRecievingParameters, initialParameters);
		Robot.receivingMacroParameters=false;
		Robot.currentMacroNameRecievingParameters = null;
	} 
}

void turnToMy(): {
} {
	< TURN_TO_MY > < LEFT_PARENTEHSIS > (< LEFT > | < RIGHT > | < BACK >) < RIGHT_PARENTEHSIS > 
}

void turnToThe(): {
} {
	< TURN_TO_THE > < LEFT_PARENTEHSIS > (< NORTH > | < SOUTH > | < EAST > | < WEST >) < RIGHT_PARENTEHSIS > 
}

void walk(): {
} {
	< WALK > < LEFT_PARENTEHSIS > n(false) < RIGHT_PARENTEHSIS > 
}

void jump(): {
} {
	< JUMP > < LEFT_PARENTEHSIS > n(false) < RIGHT_PARENTEHSIS > 
}

void drop(): {
} {
	< DROP > < LEFT_PARENTEHSIS > n(false) < RIGHT_PARENTEHSIS > 
}

void grab(): {
} {
	< GRAB > < LEFT_PARENTEHSIS > n(false) < RIGHT_PARENTEHSIS > 
}

void letGo(): {
} {
	< LET_GO > < LEFT_PARENTEHSIS > n(false) < RIGHT_PARENTEHSIS > 
}

void moves(): {
} {
	< MOVES > < LEFT_PARENTEHSIS > (< FORWARD > | < RIGHT > | < LEFT > | < BACKWARDS >) (< COMMA > (< FORWARD > | < RIGHT > | < LEFT > | < BACKWARDS >))* < RIGHT_PARENTEHSIS > 
}

void safeExe(): {
} {
	< SAFE_EXE > < LEFT_PARENTEHSIS > (walk() | jump() | drop() | pick() | grab() | letGo() | pop()) < RIGHT_PARENTEHSIS > 
}

void controlStructure(): {
} {
		iff() | doo() | rep()
}

void iff(): {
} {
		< IF > < LEFT_PARENTEHSIS > condition() < RIGHT_PARENTEHSIS > < THEN > B() < ELSE > B() < FI >
}

void doo(): {
} {
		< DO > < LEFT_PARENTEHSIS > condition() < RIGHT_PARENTEHSIS > B() < OD >
}

void rep(): {
} {
		< REP > n(false) < TIMES >  B() < PER >
}

void condition(): {
} {
	isBlocked() | isFacing() | zero() | not()		
}


void isBlocked(): {
} {
	< IS_BLOCKED > < LEFT_PARENTEHSIS > (< LEFT > | < RIGHT > | < FRONT > | < BACK >) < RIGHT_PARENTEHSIS >
}

void isFacing(): {
} {
	< IS_FACING > < LEFT_PARENTEHSIS > (< NORTH > | < SOUTH > | < EAST > | < WEST >) < RIGHT_PARENTEHSIS >
}

void zero(): {
} {
	< ZERO > < LEFT_PARENTEHSIS > n(false) < RIGHT_PARENTEHSIS >
}

void not(): {
} {
	< NOT > < LEFT_PARENTEHSIS > condition() < RIGHT_PARENTEHSIS >
}





// ------------------------------------------

/*
void put() :
{
	int f=1;	
}
{
	( <CHIPS>    "," f=num() {world.putChips(f); salida = "Command:  Put Chips"; })
	|  	  ( <BALLOONS>   "," f=num() {world.putBalloons(f); salida = "Command:  Put Balloons";})	 

}


void get() :
{
	int f=1;	
}
{
	( <CHIPS>   "," f=num() {world.pickChips(f);salida = "Command:  Pick chips";})
	|  	  ( <BALLOONS>   "," f=num() {world.grabBalloons(f);salida="Command:  Pick balloons";})	 

}






int num() throws Error:
{	
	int total=1;
}
{
	<NUMBER>
	{
		try 
		{
			total = Integer.parseInt(token.image);
		} 
		catch (NumberFormatException ee) 
		{
			throw new Error("Number out of bounds: "+token.image+" !!");
		}
		return total;
	}
}

*/
